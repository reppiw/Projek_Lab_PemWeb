<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Simple Shooter — Improved</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
        html,body{height:100%;margin:0;color:#fff;font-family:Arial,Helvetica,sans-serif;background:linear-gradient(
            rgba(0, 0, 0, 0.5),
            rgba(0, 0, 0, 0.5)
        ), url("gameyay/game/cover.jpg")}
        .wrap{display:flex;flex-direction:column;align-items:center;padding:16px;gap:12px}

        .hud{width: min(1100px, 95%);max-width:95%;display:flex;justify-content:space-between;align-items:flex-start;gap:12px}
        .score{font-size:20px;font-weight:bold}
        .instructions{font-size:13px;opacity:.75;margin-top:6px}

        button{background:#444;color:#fff;border:0;padding:6px 12px;border-radius:6px;cursor:pointer;transition:0.2s}
        button:hover{background:#555}
        #resetHS{background:#703333}
        #resetHS:hover{background:#8a3d3d}

        #highscores{min-width:200px;background:rgba(0,0,0,0.3);padding:10px 12px;border-radius:6px;font-size:13px}
        #highscores strong{display:block;margin-bottom:6px;font-size:14px}

        canvas{background:linear-gradient(#7ec0ff,#87ceeb 60%);border:4px solid #333;border-radius:6px;display:block;max-width:100%;height:auto}
    </style>
</head>
<body>
    <div class="wrap">
        <div class="hud">
            <div>
                <div class="score">Score: <span id="score">0</span></div>
                <div class="instructions">Controls: A / D or Arrow Keys to turn, Space / Click to shoot</div>
            </div>
            <div>
                <div style="display:flex;gap:8px;margin-bottom:6px">
                    <button id="saveScore">Save Score</button>
                    <button id="resetHS">Reset Highscores</button>
                </div>
                <div id="highscores">
                    <strong>Highscores</strong>
                    <div id="hsList">(loading...)</div>
                </div>
            </div>
        </div>

        <canvas id="game" width="1100" height="660"></canvas>
    </div>

    <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const groundY = Math.round(H * 0.78);

    const sprites = {
        background: new Image(),
        player: new Image(),
        enemy: new Image(),
        bullet: new Image(),
        floor: new Image()
    };

    sprites.background.src = "gameyay/game/background.png";
    sprites.player.src = "gameyay/game/player.png";
    sprites.enemy.src = "gameyay/game/enemy.png";
    sprites.bullet.src = "gameyay/game/bullet.png";
    sprites.floor.src = "gameyay/game/floor.png";

    const scoreEl = document.getElementById('score');
    const saveBtn = document.getElementById('saveScore');
    const resetBtn = document.getElementById('resetHS');
    const hsListEl = document.getElementById('hsList');

    let player = {
        x: W / 2,
        y: groundY - 105,
        w: 100,
        h: 110,
        facing: 1,
        hp: 100,
        maxHp: 100,
        inv: 0 
    };
    let bullets = [];
    let enemies = [];
    let score = 0;

    const HIGHSCORE_KEY = 'geometrisatu_highscores_v1';

    const loadHighscores = () => {
        try { return JSON.parse(localStorage.getItem(HIGHSCORE_KEY)) || []; }
        catch { return []; }
    };

    const writeHighscores = (list) => {
        try { localStorage.setItem(HIGHSCORE_KEY, JSON.stringify(list)); } catch {}
    };

    function saveHighscore(name, sc) {
        const list = loadHighscores();
        list.push({name: name || 'Player', score: sc || 0, date: new Date().toISOString()});
        list.sort((a,b) => b.score - a.score);
        writeHighscores(list.slice(0, 10));
        renderHighscores();
    }

    function renderHighscores() {
        const list = loadHighscores();
        hsListEl.innerHTML = '';
        if (list.length === 0) { hsListEl.textContent = '(no highscores yet)'; return; }

        const ol = document.createElement('ol');
        list.forEach(it => {
            const li = document.createElement('li');
            li.textContent = `${it.name} — ${it.score}`;
            ol.appendChild(li);
        });
        hsListEl.appendChild(ol);
    }

    function resetHighscores() { localStorage.removeItem(HIGHSCORE_KEY); renderHighscores(); }

    saveBtn.onclick = () => {
        if (score <= 0) return alert('Score is zero — play to score points first.');
        const name = prompt('Name for highscore (max 20 chars):', 'Player') || 'Player';
        saveHighscore(name.substring(0,20), score);
    };

    resetBtn.onclick = () => { if (confirm('Reset all highscores?')) resetHighscores(); };

    renderHighscores();

    let keyLeft = false, keyRight = false;

    window.onkeydown = (e) => {
        if (e.key === 'ArrowLeft' || e.key === 'a') keyLeft = true, player.facing = -1;
        if (e.key === 'ArrowRight' || e.key === 'd') keyRight = true, player.facing = 1;
        if (e.code === 'Space') shoot(player.facing);
    };

    window.onkeyup = (e) => {
        if (e.key === 'ArrowLeft' || e.key === 'a') keyLeft = false;
        if (e.key === 'ArrowRight' || e.key === 'd') keyRight = false;
    };

    canvas.addEventListener('pointerdown', e => {
        const rect = canvas.getBoundingClientRect();
        const cx = (e.clientX - rect.left) * (canvas.width / rect.width);
        const dir = cx < player.x ? -1 : 1;
        player.facing = dir;
        shoot(dir);
    });

    function shoot(dir) {
        bullets.push({x: player.x + dir * (player.w/2 + 6), y: player.y + player.h*0.45, vx: dir * 6.5, r: 10});
    }

    function bulletHitsEnemy(b, e) {
        const cx = Math.max(e.x, Math.min(b.x, e.x + e.w));
        const cy = Math.max(e.y, Math.min(b.y, e.y + e.h));
        return (b.x-cx)**2 + (b.y-cy)**2 <= b.r*b.r;
    }

    function spawnEnemy() {
        const fromLeft = Math.random() < 0.5;
        const speed = 1.2 + Math.random()*1.2;
        const w = 60, h = 65;
        enemies.push({ x: fromLeft ? -w-10 : W+10, y: groundY-h+5, w, h, vx: fromLeft ? speed : -speed });
    }

    const drawPlayer = () => {
        ctx.save();
        ctx.translate(player.x, player.y);
        ctx.scale(player.facing, 1);
        ctx.drawImage(sprites.player, -player.w/2, 0, player.w, player.h);
        ctx.restore();
    };

    function drawHealthBar() {
        const barWidth = 120;
        const barHeight = 14;
        const x = player.x - barWidth / 2;
        const y = player.y - 20;

        const pct = player.hp / player.maxHp;

        // background bar
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(x, y, barWidth, barHeight);

        // red missing hp
        ctx.fillStyle = "#802020";
        ctx.fillRect(x, y, barWidth, barHeight);

        // green hp
        ctx.fillStyle = "#20ff20";
        ctx.fillRect(x, y, barWidth * pct, barHeight);

        // outline
        ctx.strokeStyle = "#000";
        ctx.strokeRect(x, y, barWidth, barHeight);
    }

    const drawBullet = b => ctx.drawImage(sprites.bullet, b.x-b.r, b.y-b.r, b.r*2, b.r*2);
    const drawEnemy = (e) => {
        ctx.save();
        const dir = e.vx > 0 ? -1 : 1;

        ctx.translate(e.x + e.w / 2, e.y + e.h / 2);
        ctx.scale(dir, 1);

        ctx.drawImage(
            sprites.enemy,
            -e.w / 2,
            -e.h / 2,
            e.w,
            e.h
        );

        ctx.restore();
    };
    const drawGround = () => ctx.drawImage(sprites.floor, 0, groundY, W, H-groundY);

    let last = performance.now(), spawnTimer = 0;
    const spawnInterval = 1000;

    function loop(now) {
        const dt = now - last; last = now;

        spawnTimer += dt;
        if (spawnTimer >= spawnInterval) spawnTimer = 0, spawnEnemy();

        bullets = bullets.filter(b => {
            b.x += b.vx;
            if (b.x < -20 || b.x > W+20) return false;
            for (let i = enemies.length-1; i >= 0; i--) {
                if (bulletHitsEnemy(b, enemies[i])) {
                    enemies.splice(i,1);
                    score++;
                    scoreEl.textContent = score;
                    return false;
                }
            }
            return true;
        });

        enemies = enemies.filter(e => {
            e.x += e.vx;

            const stopL = player.x - 60;
            const stopR = player.x + 20;
            if ((e.vx > 0 && e.x > stopL) || (e.vx < 0 && e.x < stopR)) {
                e.vx *= 0.65;
            }

            if (player.inv <= 0) {
                const hit =
                    e.x < player.x + player.w/2 &&
                    e.x + e.w > player.x - player.w/2 &&
                    e.y < player.y + player.h &&
                    e.y + e.h > player.y;

                if (hit) {
                    player.hp -= 20;      
                    player.inv = 40; 
                    if (player.hp <= 0) {
                        alert("You died! Final score: " + score);
                        location.reload();
                    }
                }
            }

            return e.x > -200 && e.x < W + 200;
        });
        
        if (player.inv > 0) player.inv--;

        ctx.drawImage(sprites.background, 0, 0, W, H);
        drawGround();
        drawPlayer();
        enemies.forEach(drawEnemy);
        bullets.forEach(drawBullet);
        drawHealthBar();

        requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);
    spawnEnemy();
    spawnEnemy();
    </script>
</body>
</html>